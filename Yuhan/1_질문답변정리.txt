=============================================================================

c++ 질문_ 답변 정리

=============================================================================

< 1반 >

1. 객체는 인터페이스를 통해 접근 가능
   인터페이스 의미 : 접근 가능한 접점 : 무엇의 인터페이스냐에 따라서 다양하게 해석


2. 멤버 접근권한지정 (private, public, protected) 
   접근을 통제한다고 해서 접근을 못하는 것은 아님
   접근을 할 수 있으나 접근지정자에 따라서 거부되는 것임
   접근이 거부되는 것을 접근 못한다는 표현을 하기도 하지만 정확히는 거부되는 것임
   -> 정리하자면 접근을 못한다는 개념보다는 거부된다는 개념

3. 객체가 만들어지면 객체 안에는 멤버변수, 멤버함수가 존재 
   멤버함수의 종류는 일반 멤버함수, 생성자, 소멸자로 구분
   생성자는 1개 이상 필수로 존재, 소멸자는 1개만 존재
   일반 멤버함수는 0개 이상 존재

4. 소멸자로 객체가 사라지는 것이 아님
   객체가 소멸될 때 소멸자가 동작한다는 개념임
   함수는 메모리에서 꺼내 쓰는 것이 아니고 호출되는 것임
   객체 안에 멤버 함수는 객체의 인터페이스를 통하여 접근하여 사용
   -> 추가
   소멸자는 객체가 소멸될 때 생성되는 것이 아니고 객체가 소멸될 때 
   객체 내부에 있는 소멸자가 호출되어 실행되는 것임
   객체가 소멸되면 객체 내부를 논하는 것은 무의미함
   소멸이란 완전히 흔적조차 없이 없어지는 것임
   소멸자는 객체가 소멸될 때 객체 외에 할당 받은 자원같은 것을 반환하는 멤버함수임 
   일반적인 경우에는 객체는 생성의 역순으로 소멸됨, 하지만 꼭 그런것은 아님
   컴파일러가 생성자가 전혀 없는 경우 자동으로 한개의 기본 생성자를 만들어서 컴파일 함
   컴파일러가 소멸자가 전혀 없는 경우 자동으로 한개의 기본 소멸자를 만들어서 컴파일 함

5. 접근지정자 (private, public, protected)
   객체를 만들 때는 단일 클래스로 객체를 만들거나
   다른 클래스를 상속 받아서 객체를 만듬
   이렇게 만들어진 객체에서 다음 접근 지정자에 의해서 
   인터페이스를 통하여 접근할 때 접근지정에 따라서 접근이 거부되거나 허용되는 것임
   private : 해당 클래스 내부의 멤버함수만 접근 가능
	     해당 클래스를 상속받은 클래스의 멤버함수나 외부에서 접근하면 거부 
   protected : 해당 클래스 내부의 멤버함수와 해당 클래스를 상속받은 클래스의 멤버함수 접근 가능
               외부에서 접근하면 거부함
   public : 해당 클래스 내부의 멤버함수와 해당 클래스를 상속받은 클래스의 멤버함수 접근 가능
            외부에서도 접근 가능

접근 할 수 없는 클래스 내부의 맴버변수나 맴버함수를 접근 하기 위해서는 
클래스 내부에서 getter와 setter 같은 맴버 변수를 만들어서 제공하여야 하며
적어도 getter와 setter는 접근 가능해야 이것도 가능함
또 하나의 방법은friend를 선언하여 어디서나 접근 가능하게 해줄수 있음
friend는 객체내의 모든 맴버변수와 맴버함수에 접근 가능하게 해줌


6. 컴퓨터의 하드웨어는 주메모리와 힙메모리 공간으로 나누어져 있고
   이중 주메모리는 이름을 가지고 생성되어 지는 공간으로
   우리가 프로그램을 작성하고 실행할 경우 일반적인 경우에 주메모리에 올라가고
   해당 프로그램이 종료되기 전까지는 메모리 해제가 불가능함
   객체를 주메모리에 만들려면 꼭 이름을 주어서 생성하고 이 객체는 프로그램 종료시에 소멸됨 
   힙메모리 공간은 이름을 줄수 없는 공간으로 포인터를 이용하여 공간을 확보하여야 함
   힙메모리에는 객체나 변수등 다양한 것을 포인터를 사용하여 만들 수 있음
   힙메모리를 사용하는 이유는 프로그램 실행중에 필요시 만들고 불필요시 삭제할 수 있음
   객체나 변수를 힙메모리에 생성하면 포인터를 이용하여 삭제하여 메모리를 반환가능 함
   그런데 객체나 변수를 정상적으로 삭제하지 않고 포인터의 주소를 변경하거나
   포인터를 삭제하면 힙메모리 공간에 객체나 변수가 남아있고 메모리 반환이 안되고 있어
   메모리 누수가 일어남
   이렇게 프로그래머가 메모리 누수가 일어나는 프로그램을 작성하는 실수를 하는 경우가
   많아서 시스템이 다운되거나 이러한 일이 발생하므로 OS는 주기적으로 힙메모리 공간을
   확인하여 정리 작업을 진행하고 이때 정리되지만 프로그램이 종료되어도 힙메모리 공간을
   차지하고 있어서 시스템에 악영향을 줌
   힙메모리를 사용하기 위해서 사용하는 처음에는 포인터는 주메모리 공간에 꼭 만들고 
   힙메모리 공간을 할당받아야 하고 2차 이상은 힙메모리 공간에 포인터를 만들수도 있음
   C언어에서 포인터를 배웠겠지만 이건 포인터의 진정한 의미를 배운것이 아니고
   객체지향에서 사용되는 개념을 좀 더 배워야 함

7. new 연산자로 동적으로 힙메모리에 자료형, 객체 등등을 할당하는 것임
  (설명시 동적메모리 할당이라고 줄여 말하는 것임)
   메로리가 힙공간에 생기는 것이 아니고 힙메모리에 객체등이 만들어지는 것임
   주메모리에 할당하면 프로그램 종료시에 실행된다고 했는데 프로그램 종료란 함수종료도 포함되는 개념임
   즉 정적할당은 메모리의 효율적인 사용이 아니기 때문에 효율적으로 사용하기 위함

< 2반 >

1. 함수원형은 함수구현보다 앞에 있어야 함
   함수원형은 앞으로 내가 이 함수를 기술할거야 그런 의미인데 순서가 바뀌면 아노딤
   함수원형을 미리 선언해서 컴파일러가 컴파일을 원활히 하도록 해주고 
   헤더파일에는 함수원형을 기술해서 다른 사용자가 어떻게 호출하는지 알수있음

2. 소멸자는 객체가 사라질 때 호출되는 것임
   객체가 소멸되면 객체가 가지고 있는 멤버변수, 멤버함수가 소멸됨

3. 오버로딩이란 똑같은 이름에 다른 매개변수 받은 하나의 이름을 공유하여 쓰는 함수라는 의미
     

4. 1. 인터페이스는 광의로 접근가능한 접점이라는 뜻으로 public 과는 무관한 내용
      객체지향에서 캡슐화는 내부를 보호 한다는 의미
      인터페이스를 상속받는 것이 아니고 인터페이스를 통해 접근 한다는 의미
   2. 요즘 나오는 객체지향언어중 일부분은 인터페이스를 소의로서 추상적인 맴버만 가지는 것으로
      일종의 규칙을 가지고 다중 상속 할 수 있도록 제공되는 의미로 사용
   3. C++은 소의는 존재하지 않으므로 자동캐스팅 질문은 맞지 않음
   4. C++에서 자동캐스팅은 다음 자료타입에서 일어나며 작은 것에서 큰것으로만 가능함
      byte(char) -> short -> int -> long -> float -> double






