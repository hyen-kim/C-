=============================================================================

c++ 질문_ 답변 정리

=============================================================================

< 1반 >

1. 객체는 인터페이스를 통해 접근 가능
   인터페이스 의미 : 접근 가능한 접점 : 무엇의 인터페이스냐에 따라서 다양하게 해석

2. 멤버 접근권한지정 (private, public, protected) 
   접근을 통제한다고 해서 접근을 못하는 것은 아님
   접근을 할 수 있으나 접근지정자에 따라서 거부되는 것임 
   접근이 거부되는 것을 접근 못한다는 표현을 하기도 하지만 정확히는 거부되는 것임
   -> 정리하자면 접근을 못한다는 개념보다는 거부된다는 개념

3. 멤버변수, 멤버함수는 클래스 내부에서 선언해준 것이고 클래스로 객체를 만들면,
   객체 내부에 존재하게 되는 것임

   객체가 만들어지면 객체 안에는 멤버변수, 멤버함수가 존재 
   멤버함수의 종류는 일반 멤버함수, 생성자, 소멸자로 구분
   생성자는 1개 이상 필수로 존재, 소멸자는 1개만 존재
   일반 멤버함수는 0개 이상 존재
   

   ex)
   class Test {
 		private:
		int a;
		int b;
		public:
		int getA();
		int setB(); };
   -> 위의 Test Class에서 a, b를 멤버변수, getA(), setB()를 일반멤버함수
      추가적으로 생성자, 소멸자도 멤버함수의 한 종류이므로 생성자, 소멸자를 제외한 멤버함수는
      일반멤버함수라고 부르는 것이 좋음
      전체를 지칭할 때는 멤버함수 (생성자, 소멸자, 일반멤버함수)

   -> 중요한 개념은 객체가 생성이되야 객체 내부에 존재함

   -> 여러개의 생성자를 만드는 이유 : 클래스로 객체를 만들 때 다양하게 만들 수 있음


4. 소멸자로 객체가 사라지는 것이 아님
   함수는 메모리에서 꺼내 쓰는 것이 아니고 "호출"되는 것임
   객체 안에 멤버 함수는 객체의 인터페이스를 통하여 접근하여 사용
   소멸자는 객체가 소멸될 때 생성되는 것이 아니고, 객체가 소멸될 때 
   객체 내부에 있는 소멸자가 호출되어 실행되는 것임

   객체가 소멸되면 객체 내부를 논하는 것은 무의미함
   소멸이란 완전히 흔적조차 없이 없어지는 것임
   소멸자는 객체가 소멸될 때 객체 외에 할당 받은 자원같은 것을 반환하는 멤버함수임 
   일반적인 경우에는 객체는 생성의 역순으로 소멸됨, 하지만 꼭 그런것은 아님 => 정적인경우와, 동적인 경우가 달름

   컴파일러가 생성자가 전혀 없는 경우 자동으로 한개의 기본 생성자를 만들어서 컴파일 함 -> 아무것도 들어있지 않음
   컴파일러가 소멸자가 전혀 없는 경우 자동으로 한개의 기본 소멸자를 만들어서 컴파일 함 -> 아무것도 들어있지 않음

   같은 클래스로 만든 객체가 여러개인데 하나를 다 사용해서 소멸시키면 나머지도 소멸되는 것이 아님
   다른 객체는 사용을 다해서 실행중에 소멸시키거나(동적) 프로그램 종료시에 소멸시킴

5. 접근지정자 (private, public, protected)
   객체를 만들 때는 단일 클래스(상속받지않고 만든 클래스)로 객체를 만들거나
   다른 클래스를 상속 받아서 객체를 만듬
   이렇게 만들어진 객체에서 다음 접근 지정자에 의해서 
   인터페이스를 통하여 접근할 때 접근지정에 따라서 접근이 거부되거나 허용되는 것임

   private   : 해당 클래스 내부의 멤버함수만 접근 가능	
	       해당 클래스를 상속받은 클래스의 멤버함수나 외부에서 접근하면 거부 
   protected : 해당 클래스 내부의 멤버함수와 해당 클래스를 상속받은 클래스의 멤버함수 접근 가능 -> 하위클래스도 접근 가능
               외부에서 접근하면 거부함	
   public    : 해당 클래스 내부의 멤버함수와 해당 클래스를 상속받은 클래스의 멤버함수 접근 가능
               외부에서도 접근 가능

   접근 할 수 없는 클래스 내부의 맴버변수나 맴버함수를 접근 하기 위해서는 
   클래스 내부에서 getter와 setter 같은 맴버 변수를 만들어서 제공하여야 하며
   적어도 getter와 setter는 접근 가능해야 이것도 가능함
   *) getter : 변수값을 읽어냄
   *) getter 와 setter을 쓰는 이유는 멤버변수를 private로 선언해놓고 값을 세팅하거나 읽어오게하기위해

   또 하나의 방법은friend를 선언하여 어디서나 접근 가능하게 해줄수 있음
   friend는 객체내의 모든 맴버변수와 맴버함수에 접근 가능하게 해줌
   *) 캡슐화 원칙을 깨는 것이므로 왠만하면 사용하지 않음


6. 컴퓨터의 하드웨어는 주메모리와 힙메모리 공간으로 나누어져 있고
   이중 주메모리는 이름을 가지고 생성되어 지는 공간으로
   우리가 프로그램을 작성하고 실행할 경우 일반적인 경우에 주메모리에 올라가고
   해당 프로그램이 종료되기 전까지는 메모리 해제가 불가능함
   객체를 주메모리에 만들려면 꼭 이름을 주어서 생성하고 이 객체는 프로그램 종료시에 소멸됨 
   힙메모리 공간은 이름을 줄수 없는 공간으로 포인터를 이용하여 공간을 확보하여야 함
   힙메모리에는 객체나 변수등 다양한 것을 포인터를 사용하여 만들 수 있음
   힙메모리를 사용하는 이유는 프로그램 실행중에 필요시 만들고 불필요시 삭제할 수 있음
   객체나 변수를 힙메모리에 생성하면 포인터를 이용하여 삭제하여 메모리를 반환가능 함
   그런데 객체나 변수를 정상적으로 삭제하지 않고 포인터의 주소를 변경하거나
   포인터를 삭제하면 힙메모리 공간에 객체나 변수가 남아있고 메모리 반환이 안되고 있어
   메모리 누수가 일어남
   이렇게 프로그래머가 메모리 누수가 일어나는 프로그램을 작성하는 실수를 하는 경우가
   많아서 시스템이 다운되거나 이러한 일이 발생하므로 OS는 주기적으로 힙메모리 공간을
   확인하여 정리 작업을 진행하고 이때 정리되지만 프로그램이 종료되어도 힙메모리 공간을
   차지하고 있어서 시스템에 악영향을 줌
   힙메모리를 사용하기 위해서 사용하는 처음에는 포인터는 주메모리 공간에 꼭 만들고 
   힙메모리 공간을 할당받아야 하고 2차 이상은 힙메모리 공간에 포인터를 만들수도 있음
   C언어에서 포인터를 배웠겠지만 이건 포인터의 진정한 의미를 배운것이 아니고
   객체지향에서 사용되는 개념을 좀 더 배워야 함

   *) 정리 
   일반적으로 프로그램을 작성하고 실행할 경우에 주메모리에 올라가고, 프로그램이 종료되기 전까지 메모리 해제 불가능 
   주메모리는 이름과 주소값을 가짐, 프로그램이 종료되거나 함수가 종료될 때 함수안에 사용한 변수나 객체가 해제가 됨.
   힙메모리는 주소값만 가짐 (포인터와 함께 사용), 메모리 누수가 발생할 수도 있음


7. new 연산자로 동적으로 힙메모리에 자료형, 객체 등등을 할당하는 것임
  (설명시 동적메모리 할당이라고 줄여 말하는 것임)
   메로리가 힙공간에 생기는 것이 아니고 힙메모리에 객체등이 만들어지는 것임
   주메모리에 할당하면 프로그램 종료시에 실행된다고 했는데 프로그램 종료란 함수종료도 포함되는 개념임
   즉 정적할당은 메모리의 효율적인 사용이 아니기 때문에 효율적으로 사용하기 위함

8. c string
   한글은 두칸씩 사용, 영문이나 숫자문자는 한칸씩 사용
   마지막에 \0이 꼭 들어가야함
   \0이 들어가지 않으면 char형 배열이 되는 것임

9. cin.getline()이 함수 원형이고 namespace std에 들어있음
   std는 using namespace를 이용해서 생략가능함 
   함수원형 : 함수를 호출하는 방식을 미리 선언해준 것
              실제로 함수는 다시 구현부에 구현해 주어야 함
   
   형식 : using namespace namespace명 
   다른 using namespace도 using으로 지정하여 생략가능 하지만 함수가 중복되어
   문제가 발생하거나 변수가 중복되어 문제가 발생할 수 있으므로
   다른 namespace는 되도록이면 사용하지 않음
   함수가 중복된다는 말은 함수중복(오버로딩)과는 틀린 말
   함수가 중복된다는 예 int area(int a), int area(int xx)


10. 구조체 vs 클래스
    구조체는 객체가 아니기 때문에 객체지향 특성이 다 적용되는 것은 아님
    구조체는 캡슐화가 기본이 아니기 때문에 접근지정자를 지정하지 않으면 public
    클래스는 캡슐화가 기본이기 때문에 접근지정자를 지정하지 않으면 private
    -> 구조체도 상속이 가능합니다.
    -> 구조체와 클래스는 접근 지시어에서 차이를 보임

11. c string : atoi, atof, atol		-> 문자열이 들어가면 0값을 리턴
    string : stoi, stof, stol		-> 문자열이 들어가면 에러 발생
    atoi, atof, atol는 같은 동작을 함

12. 헤더파일은 내가 사용할 소스를 확장할 때 선언부 위주로 기술 된 것임
    라이브러리는 내가 사용할 자원들을 미리 만들어둔 것임
    자원의 종류는 데이터, 함수, 변수, 클래스 등등
    *) 헤더파일로 라이브러리 또는 다른 클래스나 프로그램을 확장



< 2반 >

1. 함수원형은 함수구현보다 앞에 있어야 함
   함수원형은 앞으로 내가 이 함수를 기술할거야 그런 의미인데 순서가 바뀌면 안됨
   함수원형을 미리 선언해서 컴파일러가 컴파일을 원활히 하도록 해주고 
   헤더파일에는 함수원형을 기술해서 다른 사용자가 어떻게 호출하는지 알수있음

2. 소멸자는 객체가 사라질 때 호출되는 것임
   객체가 소멸되면 객체가 가지고 있는 멤버변수, 멤버함수가 소멸됨

3. 오버로딩이란 똑같은 이름에 다른 매개변수 받은 하나의 이름을 공유하여 쓰는 함수라는 의미
     

4. ①. 인터페이스는 광의로 접근가능한 접점이라는 뜻으로 public 과는 무관한 내용
      객체지향에서 캡슐화는 내부를 보호 한다는 의미
      인터페이스를 상속받는 것이 아니고 인터페이스를 통해 접근 한다는 의미
   ②. 요즘 나오는 객체지향언어중 일부분은 인터페이스를 소의로서 추상적인 맴버만 가지는 것으로
      일종의 규칙을 가지고 다중 상속 할 수 있도록 제공되는 의미로 사용
   ③. C++은 소의는 존재하지 않으므로 자동캐스팅 질문은 맞지 않음
   ④. C++에서 자동캐스팅은 다음 자료타입에서 일어나며 작은 것에서 큰것으로만 가능함
      byte(char) -> short -> int -> long -> float -> double

5. 구조체는 객체를 만들지 못함
   그냥 집합체라고 보면됨
   상속은 받을 수 있음

6. 객체지향은 주메모리에는 이름으로 생성하고 
   힙메모리는 포인터로 생성하는 것이고 이때 new로 만들고 delete로 반납하는 것

