
================================================================================

7주차 (4장) : 객체 포인터와 객체 배열, 객체의 동적 생성과 삭제
- 과제제출방식 지키기
- 반복학습 꼭하기 

================================================================================

1. 객체에 대한 포인터
- C 언어의 포인터와 동일 
- 객체의 주소 값을 가지는 변수

2. 포인터로 멤버를 접근할 때
- 객체포인터 -> 멤버


(1) Circle *p; : Circle이라는 객체에 포인터p를 만들었음
-> p포인터는 Circle클래스로 만든 객체만 가르킬 수 있음 
-> 앞에 선언한 자료형만 가르킨다.

* 주소가 들어가는 변수를 포인터라고 생각
* 주소가 들어가는 변수란 ?
- 그 주소가 무언가를 가르켜야함



Circle donut;			// 포인터가 아님 -> 주메모리에 객체를 만든 것임
double d = donut.getArea();


Circle *p;		// (1)	객체에 대한 포인터 선언
p = &donut 		// (2)	포인터에 객체 주소 저장
d = p -> getArea();	// (3)	멤버 함수 호출


3. 객체 배열, 생성 및 소멸
배열 - 이름 하나로 여러가지 공간을 가짐

int n[3]; 	// int형이 3개 들어갈 수 있는 공간
Circle c[3];	// Circle로 만든 객체가 들어감


* 객체 배열 선언
- 객체 배열을 위한 공간 할당
- 배열의 각 원소 객체마다 생성자 실행
	-> c[0]의 생성자, c[1]의 생성자, c[2]의 생성자 실행
	-> 매개 변수 없는 생성자 호출 
- 매개 변수 있는 생성자를 호출할 수 없음
- 배열 소멸
	-> 배열의 각 객체마다 소멸자 호출, 생성의 반대순으로 소멸
		: c[2]의 소멸자, c[1]의 소멸자, c[0]의 소멸자 실행


* 객체 배열 초기화 : 배열의 각 원소 객체당 생성자 지정하는 방법
Circle circleArray[3] = {Circle(10), Circle(20), Circle() };
circleArray[0] 객체가 생성될 때, 생성자 Circle(10) 호출
circleArray[1] 객체가 생성될 때, 생성자 Circle(20) 호출
circleArray[2] 객체가 생성될 때, 기본 생성자 Circle() 호출




4. 동적 메모리 할당 및 반환
- 정적할당
	-> 변수 선언을 통해 필요한 메모리 할당
		: 많은 양의 메모리는 배열 선언을 통해 할당
- 동적할당
	-> 필요한 양이 예측되지 않는 경우, 프로그램 작성 시 할당 받을 수 없음
	-> 실행 중에 힙 메모리에서 할당
		: 힙으로부터 할당 (힙은 운영체제가 프로세스의 실행을 시작 시킬 때 동적 할당 공간으로 준 메모리 공간)
- C++의 동적 메모리 할당 / 반환
	-> new 연산자
		: 기본 타입 메모리 할당, 배열 할당, 객체 할당, 객체 배열 할당
		: 객체의 동적 생성 - 힙 메모리로부터 객체를 위한 메모리 할당 요청
		: 객체 할당 시 생성자 호출
- delete 연산자
	: new로 할당 받은 메모리 반환
	: 객체의 동적 소멸 - 소멸자 호출 뒤 객체를 힙에 반환




5. new와 delete 연산자	( 힙 메모리공간에 생성 )
- C++ 의 기본 연산자
- new/delete 연산자의 사용 형식
	-> 데이터타입 *포인터변수 = new 데이터타입;
	-> delete 포인터변수; 
	* delete를 하게 되면 힙메모리공간만 삭제됨
- new/delete의 사용

(1) int *p = new int;		=> 할당된 int 영역
(2) *p = 5;			=> p포인터 공간에 5를 넣음
(3) delete p;			=> delete 후 포인터 p는 살아있지만, 
				   p가 가리키는 곳에 접근하면 안


6. delete 사용 시 주의 사항
- 적절치 못한 포인터로 delete하면 실행 시간 오류 발생
	-> 동적으로 할당 받지 않는 메모리 반환 - 오류
	int n;
	int *p = &n;
	delete p;	
	// 포인터 p가 가리키는 메모리는 동적으로 할당 받은 것이 아님
	// n은 주메모리 공간에 할당 받은 것 이기 때문에 

- 동일한 메모리 두 번 반환 - 오류
	int *p = new int;
	delete p;	// 정상적으로 메모리 반환
	delete p;	// 메모리를 중복으로 반환할 수 없음

 

7. 배열의 동적 할당 및 반환

* new/delete 연산자의 사용 형식
데이터타입 *포인터변수 = new 데이터타입 [배열의 크기];	// 동적 배열 할당
delete [] 포인터변수; 					// 배열 반환

(1) int *p = new int [5];

(2) for (int i = 0; i < 5; i++) 
		p[i] = i;				// 배열의 포인터는 이런식으로 사용가능
(3) delete [] p;					// 이런식으로 해야 삭제가능



8. 동적 할당 메모리 초기화 및 delete 시 유의사항 
- 동적 할당 메모리 초기화
	-> 동적 할당 시 초기화
	데이터타입 *포인터변수 = new 데이터타입(초깃값);

- 배열은 동적 할당 시 초기화 불가능

- delete시 [] 생략	=> 배열이냐 아니냐에 따라
	-> 컴파일 오류는 아니지만 비정상적인 반환


클래스이름 *포인터변수 = new 클래스이름;
클래스이름 *포인터변수 = new 클래스이름 (생성자매개변수리스트);
delete 포인터변수;





9. 객체 배열의 사용, 배열의 반환과 소멸자
- 동적으로 생성된 배열도 보통 배열처럼 사용
- 포인터로 배열 접근 ( 포인터는 처음 주소를 가르킴 무조건 )
- 배열 소멸 : 생성의 반대순



10. 동적 메모리 할당과 메모리 누수
char n = 'a';
char *p = new char[1024];
p = &n;
-> p가 n을 가리키면 할당 받은 1024바이트 메모리 누수 발생



11. this 포인터 : 객체를 만들었을 때 가리키는 공간
- this
	-> 포인터, 객체 자신 포인터
	-> 클래스의 멤버 함수 내에서만 사용
	-> 개발자가 선언하는 변수가 아니고, 컴파일러가 선언한 변수
		: 멤버 함수에 컴파일러에 의해 묵시적으로 삽입 선언되는 매개 변수


class Circle {
	int radius;
public:
	Circle() {this -> radius = 1;}	
	// Circle이라는 클래스를 가리키는 것이 아니고
	// Circle A랑 Circle B가 존재한다면
	// this는 Circle A가 Circle A를 가리킨다는 말
	// this : 소스에서 가리키는 것이 아니고 Circle로 객체를 생성하면 나 안에 있는 것을 가리킨다는 말
};

* this를 쓰는 중요한 이유는 ?
- 매개변수랑 멤버변수 이름이 같은 경우
  this를 주면 멤버변수로 구분
  this를 주지 않으면 매개변수라고 구분




12. this가 필요한 경우
- 매개변수의 이름과 멤버 변수의 이름이 같은 경우
- 멤버 함수가 객체 자신의 주소를 리턴할 때
	-> 연산자 중복 시에 매우 필요
	class Sample {
	public:
		Sample *f(){
			return this;
			// 주소값이 리턴되서 날라감
		}

	};




13. this의 제약사항
- 멤버 함수가 아닌 함수에서 this 사용 불가
	-> 객체와의 관련성이 없기 때문
- static 멤버 함수에서 this 사용 불가
	-> 객체가 생기기 전에 static 함수 호출이 있을 수 있기 때문에
	* static은 정적인 의미로 공유가 된다.
	: 객체가 없어도 static으로 함수를 만들면 호출 가능




*** 중간고사 공지 ***
- 덧셈만하는 코드를 사칙연산 가능하게 수정하기
- 괄호 필요없음
- 5 - 3 * 5를 입력하였을 때 계산하는 사칙연산 구현하기 -> 10
- 우리의 소스는 순서대로 계산하는 식으로 만들기 -> 순서대로 사칙연산
- adder를 참고해서 작성
- 헤더파일에 3개 추가 - + / 
- 소스에도 cpp추가





