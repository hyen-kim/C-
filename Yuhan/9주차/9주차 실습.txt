
================================================================================

9주차 

================================================================================

< 전주차 내용 다시 복습 >

얕은 복사 (shallow copy)	-> 디폴트복사생성자가 자동으로 해줌
- 객체 복사 시, 객체의 멤버를 1:1로 복사
- 객체의 멤버 변수에 동적 메모리가 할당된 경우
	-> 사본은 원본 객체가 할당 받은 메모리를 공유하는 문제 발생

깊은 복사 (deep copy)
- 객체 복사 시, 객체의 멤버를 1:1대로 복사
- 객체의 멤버 변수에 동적 메모리가 할당된 경우
	-> 사본은 원본이 가진 메모리 크기 만큼 별도로 동적 할당
	-> 원본의 동적 메모리에 있는 내용을 사본에 복사
- 완전한 형태의 복사
	-> 사본과 원본은 메모리를 공유하는 문제 없음


* C++에서 객체의 복사

class Person {
	int id;
	char *name;
	............
};

Person 타입 객체, 원본					   복사본 객체
id	1			=== >	얕은 복사기 	=> id 	1
name							   name 
	kitae\0							앞에 name포인터를 가리킴
--> name 포인터가 복사되었기 때문에 메모리 공유! - 문제 유발


Person 타입 객체, 원본					    복사본 객체
id	1			=== > 깊은 복사기	=> id	1
name							   name  
       kitae\0							kitae\0				
--> name 포인터의 메모리도 복사되었음
--> 힙메모리 공간에 별도로 공간을 만들어서 가리키도록 함
--> 복사본이 사라지고 원본이 사라짐


예제 5-12. 묵시적 복사 생성에 의해 복사 생성자가 자동 호출되는 경우
void f(Person person) {	// 2. '값에 의한 호출'로 객체가 전달될 때,
			// person 객체의 복사 생성자 호출
	person.changeName("dummy");
}

Person g() {		// 3. 함수에서 객체를 리턴할 때,
			// mother 객체의 복사본 생성
			// 복사본의 복사 생성자 호출
	Person mother(2, "Jane");
	return mother;
}

int main() {		// 1. 객체로 초기화하여 객체가 생성될 때,
			// son 객체의 복사 생성자 호출
	Person father(1, "Kitae");	
	Person son = father;	// 객체를 만들면서 동시에 대입하면서 치환할경우 -> 복사생성자 
	f(father);
	g();			// g라는 함수를 호출하여 리턴값으로 날라오게 하여 복사
}





* 복사 생성자 (copy constructor)란 ?
- 객체의 복사 생성시 호출되는 '특별한 생성자'

* 특징
- 한 클래스에 '오직 한 개만' 선언 가능
- 복사 생성자는 보통 생성자와 클래스 내에 중복 선언 가능
- 모양
	-> 클래스에 대한 '참조 매개 변수'를 가지는 독특한 생성자

* 복사 생성자 선언
class Circle {
	......
	Circle(const Circle& c);	// 복사 생성자 선언
	// 	     자기 클래스에 대한 참조 매개 변수
	......
};

Circle::Circle(const Circle& c)	{	// 복사 생성자 구현
	......
}





* 디폴트 복사 생성자
- 복사 생성자가 선언되어 있지 않는 클래스
	-> 컴파일러는 자동으로 디폴트 복사 생성자 삽입

class Circle {
	int radius;
public:		// 복사 생성자 없음
	Circle(int r);
	double getArea();
};

Circle dest(src);	// 복사 생성. Circle(const Circle&) 호출


=>  우리가 기술하지 않은 경우
Circle::Circle(const Circle& c){	// 디폴트 복사 생성자
	this -> radius = c.radius;
	// 원본 객체 c의 각 멤버를 사본(this)에 복사한다.
}






< 06. 함수 중복과 static 멤버 >

===============================================
학습 목표
1. 함수 중복의 개념을 이해하고, 중복 함수를 작성
2. 디폴트 매개 변수를 이해하고, 작성
3. 함수 중복 시 발생하는 모호성의 경우를 판별
4. static 속성으로 선언된 멤버의 특성을 이해,
   static 속성을 활용
===============================================

01. 함수중복

< 함수 중복 >	-> 매개인자값이 다르게 (매개변수인데, 데이터타입이 다르거나, 갯수가 다른)
- 동일한 이름의 함수가 공존
	-> 다형성
	-> C 언어에서는 불가능
- function overloading
- 함수 중복이 가능한 범위
	-> 보통 함수들 사이
	-> 클래스의 멤버 함수들 사이
	-> 상속 관계에 있는 기본 클래스와 파생 클래스의 멤버 함수들 사이
- 함수 중복 성공 조건
	-> 중복된 함수들의 이름 동일
	-> 중복된 함수들의 매개 변수 타입이 다르거나 개수가 달라야 함
	-> 리턴 타입은 함수 중복과 무관
ex) 성공적으로 중복된 sum()함수들 (overloading)

int sum (int a, int b, int c) {		// 매개변수가 int형 3개
	return a + b + c;
}

int sum (int a, int b) {		// 매개변수가 itn형 2개
	return a + b;
}

double sum (double a, double) {		// 매개변수가 double형 2개
	return a + b;
}

- 함수 중복 실패 사례
	-> 리턴 타입이 다르면 함수 중복이 성공하지 않음

- 함수 중복의 편리함
	-> 동일한 이름을 사용하면 함수 이름을 구분하여 기억할 필요 없고,
	   함수 호출을 잘못하는 실수를 줄일 수 있음
	-> 호출의 편리함, 오류 가능성을 줄임




* 생성자 함수 중복 가능
- 생성자 함수 중복 목적
	-> 객체 생성시, 매개 변수를 통해 다양한 형태의 초깃값 전달

- string 클래스의 생성자 중복 사례
ex) class string {
	.....
public:
	string();	// 빈 문자열을 가진 스트링 객체 생성
	string (string& str);	// str을 복사한 새로운 스트링 객체 생성
	string (char* s);	// \0으로 끝나는 C-스트링 s를 스트링 객체로 생성
	.....
}; 

string str;	// 빈 문자열을 가진 스트링 객체
string copyAddress(address);	// address의 문자열을 복사한 별도의 copyAddress 생성
string address("서울시 성복구 삼선동 389");



* 소멸자 함수 중복 
- 소멸자 함수 중복 불가
	-> 소멸자는 매개 변수를 가지지 않음
	-> 한 클래스 내에서 소멸자는 오직 하나만 존재




* 디폴트 매개 변수
- 디폴트 매개 변수
	-> 매개 변수에 값이 넘어오지 않는 경우, 디폴트 값을 받도록 선언된 매개변수
	-> '매개 변수 = 디폴트값' 형태로 선언

- 디폴트 매개 변수 선언 사례
	-> void star(int a = 5);	// a의 디폴트 값은 5

- 디폴트 매개 변수를 가진 함수 호출
	-> star();	// 매개 변수 a에 디폴트 값 5가 전달됨.
			// star(5);와 동일
	-> star(10);	// 매개 변수 a에 10을 넘겨줌
사례1) id값은 디폴트 값을 지정하지 않음 -> id값은 꼭 들어와야하는 경우
void msg(int id, string text = "Hello");	// text의 디폴트 값은 "Hello"
msg(10);	// msg(10, "Hello"); 호출과 동일. id에 10, text에 "Hello"전달
msg(20, "Good Morning");	// id에 20, text에 "Good Morning" 전달
// 호출 오류
msg();	// 컴파일 오류. 첫 번째 매개 변수 id에 반드시 값을 전달하여야 함
msg("Hello");	// 컴파일 오류. 첫 번째 매개 변수 id에 값이 전달되지 않았음

사례2) 두개의 값 모두 디폴트 매개 변수를 가진 square() 
void square(int width = 1, int height = 1);
square();	-> 1, 1
square(5);	-> 5, 1
square(3, 8);	-> 3, 8


- 디폴트 매개 변수에 관한 제약 조건
	-> 디폴트 매개 변수는 보통 매개 변수 앞에 선언될 수 없음
	-> 디폴트 매개 변수는 끝 쪽에 몰려 선언되어야 함
ex) void calc(int a, int b = 5, int c = 0, int d = 0);	// 컴파일 성공





* 함수 중복 간소화
- 디폴트 매개 변수의 장점 - 함수 중복 간소화
- 중복 함수들과 디폴트 매개 변수를 가진 함수를 함께 사용 불가




* 형 변환으로 인한 함수 중복의 모호성
- 매개 변수의 형 변환으로 인한 중복 함수 호출의 모호성 

* 참조 매개 변수로 인한 함수 종복의 모호성

* 디폴트 매개 변수로 인한 함수 중복의 모호성








< static 멤버와 non-static 멤버 >
static : 공유되고 있는 자원	ex) 공기
non-static : 객체 		ex) 사람 하나하나 ?


* static 
- 변수와 함수에 대한 기억 부류의 한 종류
	-> 생명 주기 - 프로그램이 시작될 때 생성, 프로그램 종료 시 소멸
	-> 사용 범위 - 선언된 범위, 접근 지정에 따름

* 클래스의 멤버
- static 멤버
	-> 프로그램이 시작할 때 생성
	-> 클래스 당 하나만 생성, 클래스 멤버라고 불림
	-> 클래스의 모든 인스턴스(객체)들이 공유하는 멤버

* non-static 멤버
	-> 객체가 생성될 때 함께 생성
	-> 객체마다 객체 내에 생성
	-> 인스턴스 멤버라고 불림



* static 멤버 선언
- 멤버의 static 선언
class Person {
public:
	// non-static 멤버 선언
	int money;	// 개인 소유의 돈
	void addMoney(int money){this -> money += money;}
	
	// static 멤버 변수 선언
	static int sharedMoney;	// 공금
	// static 멤버 함수 선언
	static void addShared(int n){
		sharedMoney += n;
	}
};


// static 변수 공간 할당. 프로그램의 전역 공간에 선언
int Person::sharedMoney = 10;	// sharedMoney를 10으로 초기화




* static 멤버 변수 생성
	-> 전역 변수로 생성
	-> 전체 프로그램 내에 한 번만 생성

* static 멤버 변수에 대한 외부 선언이 없으면 다음과 같은 링크 오류

* static 멤버 사용 : 객체의 멤버로 접근
- static 멤버는 객체 이름이나 객체 포인터로 접근
	-> 보통 멤버처럼 접근할 수 있음
	객체.static멤버
	객체포인터->static멤버
- Person 타입의 객체 lee와 포인터 p를 이용하여 static 멤버를 접근하는 예
	Person lee;
	lee.sharedMoney = 500;	// 객체.static멤버 방식
	
	Person *p;
	p = &lee;
	p -> addShared(200);	// 객체포인터 -> static멤버 방식

	==> static은 공유하므로 값을 바꾸면 같이 바뀜




< static 멤버 사용 : 클래스명과 범위 지정 연산자(::)로 접근 >
- 클래스 이름과 범위 지정 연산자 (::) 로 접근 가능
	-> static 멤버는 클래스마다 오직 한 개만 생성되기 때문
	-> 클래스명::static멤버
	Person::sharedMoney = 200;
	-> non-static 멤버는 클래스 이름을 접근 불가




< static 활용 >
* static의 주요 활용 
- 전역 변수나 전역 함수를 클래스에 캡슐화
	-> 전역 변수나 전역 함수를 가능한 사용하지 않도록
	-> 전역 변수나 전역 함수를 static으로 선언하여 클래스 멤버로 선언
- 객체 사이에 공유 변수를 만들고자 할 때
	-> static 멤버를 선언하여 모든 객체들이 공유




< static 멤버 함수는 static 멤버만 접근 가능 >
- static 멤버 함수가 접근할 수 있는 것
	-> static 멤버 함수
	-> static 멤버 변수
	-> 함수 내의 지역 변수
- static 멤버 함수는 non-static 멤버에 접근 불가
	-> 객체가 생성되지 않은 시점에서 static 멤버 함수가 호출될 수 있기 때문


< static 멤버 함수는 this 사용 불가 >
- static 멤버 함수는 객체가 생기기 전부터 호출 가능
	-> static 멤버 함수에서 this 사용 불가
	// static은 객체 외부이므로 사용할 수 가 없음
	// this는 객체 내부를 가르키는 말 이므로


< static 멤버와 non-static 멤버 비교 >
		non-static 			static
선언사례	class Sample {			class Sample {
		  int n;			  static int n;
		  void f();			  static void f();
		};				};


공간특성	멤버는 객체마다 별도 생성	멤버는 클래스당 하나 생성
		인스턴스 멤버라고 불름		멤버는 객체 내부가 아닌 별도의 공간에 생성
						클래스 멤버라고 부름



시간적 특성	객체와 생명을 같이함		프로그램과 생명을 같이함
		객체 생성시에 멤버 생성		프로그램 시작시 멤버 생성
		객체 소멸시 함께 소멸		객체가 생기기전에 이미 존재
		객체 생성 후 객체 사용가능	객체가 사라져도 여전히 존재
						프로그램이 종료될 때 함께 소멸

공유의 특성	공유되지 않음			동일한 클래스의 모든 객체들에 의해 공유됨
		멤버는 객체 별로 따로 공간유지




