=============================================================

13주차

=============================================================

< 일반화와 템플릿 >

* 제네릭 또는 일반화
- 함수나 클래스를 일반화시키고, 매개 변수 타입을 지정하여 틀에서 
  찍어 내듯이 함수나 클래스 코드를 생산하는 기법

* 템플릿
- 함수나 클래스를 일반화하는 C++ 도구
- template 키워드로 함수나 클래스 선언
	: 변수나 매개 변수의 타입만 다르고, 코드 부분이 동일한 함수를 일반화 시킴
- 제네릭 타입 : 일반화를 위한 데이터 타입

* 템플릿 선언
template <class T> 또는
template <typename T>

3개의 제네릭 타입을 가진 템플릿 선언
template <class T1, class T2, class T3>

ex) 중복된 예제를 템플릿으로 이용하여 작성
template <class T>
void myswap(T & a, T & b) {	// T부분이 int나 double로 작성되어있던 부분
   T tmp;
   tmp = a;
   a = b;
   b = tmp;
}


* 구체화	--> 템플릿을 이용하여 진짜 함수로 구현하는 것
- 템플릿의 제네릭 타입에 구체적인 타입 지정
	: 템플릿 함수로부터 구체화된 함수의 소스 코드 생성


* 구체화 오류
- 제네릭 타입에 구체적인 타입 지정 시 주의

template <class T>
void myswap(T& a, T& b)

main
  int s = 4;
  double t = 5;
  myswap(s, t);
--> 이렇게 되었을 때 컴파일 오류.
    템플릿으로부터 myswap(int &, double &) 함수를 구체화할 수 없음.
    위의 myswap의 T가 같은 형이 아니므로 에러가 발생

위의 오류를 해결하기 위해선 밑에와 같이 작성
template <class T1, class T2>
void myswap(T1& a, T2& b)








< 템플릿 장점과 제네릭 프로그래밍 >

* 템플릿 장점 
- 함수 코드의 재사용
	: 높은 소프트웨어의 생산성과 유용성

* 템플릿 단점
- 포팅에 취약
	: 컴파일러에 따라 지원하지 않을 수 있음
- 컴파일 오류 메시지 빈약, 디버깅에 많은 어려움


* 제네릭 프로그래밍
- generic programming
	: 일반화 프로그래밍이라고도 부름
	: 제네릭 함수나 제네릭 클래스를 활용하는 프로그래밍 기법
	: C++ 에서 STL 제공, 활용
- 보편화 추세
	: Java, C# 등 많은 언어에서 활용







< C++ 표준 템플릿 라이브러리, STL >

* STL
- 표준 템플릿 라이브러리
	: C++ 표준 라이브러리 중 하나
- 많은 제네릭 클래스와 제네릭 함수 포함
	: 개발자는 이들을 이용하여 쉽게 응용 프로그램 작성

* STL의 구성
- 컨테이너 - 템플릿 클래스
	: 데이터를 담아두는 자료 구조를 표현한 클래스
	: 리스트, 큐, 스택, 맵, 셋, 벡터
- iterator - 컨테이너 원소에 대한 포인터
	: 컨테이너의 원소들을 순회하면서 접근하기 위해 만들어진 컨테이너 원소에 대한 포인터

- 알고리즘 - 템플릿 함수
	: 컨테이너 원소에 대한 복사, 검색, 삭제, 정렬 등의 기능을 구현한 템플릿 함수
	: 컨테이너의 멤버 함수 아님







< STL 컨테이너의 종류 >
1. vector 	: 가변 크기의 배열을 일반화한 클래스 
2. map 		: (key, value) 쌍을 저장하는 맵 클래스  







< STL과 관련된 헤더 파일과 이름 공간 >

* 헤더파일
- 컨테이너 클래스를 사용하기 위한 헤더 파일
	: 해당 클래스가 선언된 헤더 파일 include
	예) vector 클래스를 사용하려면 #include <vector>

* 알고리즘 함수를 사용하기 위한 헤더파일
	: 알고리즘 함수에 상관 없이 #include <algorithm>

* 이름 공간
	: STL이 선언된 이름 공간은 std







< vector 컨테이너 >

* 특징
- 가변 길이 배열을 구현한 제네릭 클래스
	: 개발자가 벡터의 길이에 대한 고민할 필요 없음
- 원소의 저장, 삭제, 검색 등 다양한 멤버 함수 지원
- 벡터에 저장된 원소는 인텍스로 접근 가능
	: 인텍스는 0부터 시작

* 멤버와 연산자 함수
- push_back(element)	: 벡터의 마지막에 element 추가
- at(int index)		: index 위치에 원소에 대한 참조 리턴
- begin()		: 벡터의 첫 번째 원소에 대한 참조 리턴
- end()			: 벡터의 끝(마지막 원소 다음)을 가리키는 참조 리턴
- empty()		: 벡터가 비어 있으면 true 리턴
- erase(iterator it)	: 벡터에서 it가 가리키는 원소 삭제, 삭제 후 자동으로 벡터 조절
- insert(iterator it, element) : 벡터 내 it 위치에 element 삽입
- size()		: 벡터에 들어 있는 원소의 개수 리턴
- operator[]()		: 지정된 원소에 대한 참조 리턴
- operator=()		: 이 벡터를 다른 벡터에 치환(복사)






< iterator 사용 >
- 반복자라고도 부름
- 컨테이너의 원소를 가리키는 포인터

* iterator 변수 선언
- 구체적인 컨테이너를 지정하여 반복자 변수 생성
vector<int>::iterator it;





< map 컨테이너 >

* 특징
- ('키', '값')의 쌍을 원소로 저장하는 제네릭 컨테이너
	: 동일한 '키'를 가진 원소가 중복 저장되면 오류 발생
- '키'로 '값' 검색
- 많은 응용에서 필요함
- #include <map> 필요

* 맵 컨테이너 생성 예
- 영한 사전을 저장하기 위한 맵 컨테이너 생성 및 활용
	: 영어 단어와 한글 단어를 쌍으로 저장하고, 영어 단어로 검색
// 맵 생성
Map<string, string> dic;	// 키는 영어 단어, 값은 한글 단어

// 원소 저장
dic.insert(make_pair("love", "사랑"));	// ("love", "사랑") 저장
dic["love"] = "사랑";			// ("love", "사랑") 저장

// 원소 검색	--> 값이 읽혀나온다는 개념
string kor = dic["love"];		// kor은 "사랑"
string kor = dic.at("love");		// kor은 "사랑"

* 멤버와 연산자 함수
- insert(pair<> &element) 	: 맵에 '키'와 '값'으로 구성된 pair 객체 element 삽입
- at(key_type&key)		: 맵에서 '키' 값에 해당하는 '값' 리턴
- begin()			: 맵의 첫 번째 원소에 대한 참조 리턴
- end()				: 맵의 끝(마지막 원소 다음)을 가리키는 참조 리턴
- empty()			: 맵이 비어 있으면 true 리턴
- find(key_type& key)		: 맵에서 '키' 값에 해당하는 원소를 가리키는 iterator 리턴
- erase(iterator it) 		: 맵에서 it가 가리키는 원소 삭제 
- size()			: 맵에 들어 있는 원소의 개수 리턴
- operator[key_type& key]	: 맵에서 '키' 값에 해당하는 원소를 찾아 '값' 리턴
- operator=()			: 맵 치환(복사)







< STL 알고리즘 사용하기 >

* 알고리즘 함수
- 템플릿 함수
- 전역 함수
	: STL 컨테이너 클래스의 멤버 함수가 아님 
- iterator와 함께 작용

* sort() 함수 사례
- 두개의 매개 변수
	: 첫 번째 매개 변수 : 소팅을 시작한 원소의 주소
	: 두 번째 매개 변수 : 소팅 범위의 마지막 원소 다음 주소

