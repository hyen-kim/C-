=============================================================

12주차

01. 상속에서 함수 재정의
02. 가상 함수와 오버라이딩, 동적바이딩
03. 가상 소멸자
04. 가상 함수
05. 순수가상함수와 추상 클래스

=============================================================

01. 함수 재정의 ( 정적 )
- 함수의 재정의란 가장 마지막의 함수가 호출되도록 하는 것





02. 가상 함수와 오버라이딩

* 가상 함수
- virtual 키워드로 선언된 멤버 함수
- virtual 키워드의 의미
	: 동적 바인딩 지시어
	: 컴파일러에게 함수에 대한 호출 바인딩을 실행 시간까지 미루도록 지시
	class Base {
	public:
	  virtual void f();	// f()는 가상 함수
	};

* 함수 오버라이딩 ( 동적 )
- 파생 클래스에서 기본 클래스의 가상 함수와 동일한 이름의 함수 선언
	: 기본 클래스의 가상 함수의 존재감 상실시킴
	: 파생 클래스에서 오버라이딩한 함수가 호출되도록 동적 바인딩
	: 함수 재정의라고도 부름
	: 다형성의 한 종류




< 함수 재정의와 오버라이딩 용어의 혼란 정리 >
- 함수 재정의라는 용어를 사용할 때 신중을 가해야 한다.
  가상 함수를 재정의하는 경우와 아닌 경우에 따라 프로그램의 실행이 완전히 달라지기 때문이다.

  가상 함수를 재정의하는 오버라이딩의 경우 함수가 호출되는 실행 시간에 
  동적 바인딩이 일어나지만, 그렇지 않은 경우 컴파일 시간에 결정된 함수가 단순히 호출된다.
  (정적바인딩)
  
  저자는 가상 함수를 재정의하는 것을 오버라이딩으로, 그렇지 않는 경우를 함수 재정의로 구분하고자 한다.
   

* 오버라이딩의 목적 - 파생 클래스에서 구현할 함수 인터페이스 제공 (파생 클래스의 다형성)


* 동적 바인딩	--> 가상 함수가 작성되어 있는 하위에 있는 가장 마지막 함수가 호출되는 것이다 라고 보면 됨
		--> 객체를 무조건 읽어서 우선순위에 따라 처리하는 과정이라고 보면됨
		--> 판단해서 하는 것이 아니라 파생 클래스에 의해 하는 것임 그래서 빠른 것임
- 파생 클래스에 대해
- 기본 클래스에 대한 포인터로 가상 함수를 호출하는 경우
- 객체 내에 오버라이딩한 파생 클래스의 함수를 찾아 실행
	: 실행 중에 이루어짐
		-> 실행시간 바인딩, 런타임 바인딩, 늦은 바인딩으로 불림



* C++ 오버라이딩의 특징

- 오버라이딩의 성공 조건
: 가상 함수 이름, 매개 변수 타입과 개수, 리턴 타입이 모두 일치

- 오버라이딩 시 virtual 지시어 생략 가능
: 가상 함수의 virtual 지시어는 상속됨, 파생 클래스에서 virtual 생략 가능

- 가상함수의 접근 지정
: private, protected, public 중 자유롭게 지정 가능


* 오버라이딩과 범위 지정 연산자 (::)

- 범위 지정 연산자 (::)
: 정적 바인딩 지시
: 기본클래스::가상함수()형태로 기본 클래스의 가상 함수를 정적바인딩으로 호출







03. 가상 소멸자

* 가상 소멸자
- 소멸자를 virtual 키워드로 선언
- 소멸자 호출 시 동적 바인딩 발생

1. 업캐스팅 된 포인터로 객체를 삭제
2. 하위의 소멸자가 실행되어야 할 때
---> 1, 2번 두개 다 만족해야 가상 소멸자를 작성할 수 있음


* 오버로딩과 함수 재정의, 오버라이딩 비교

1. 오버로딩
- 매개 변수 타입이나 개수가 다르지만 이름이 같은 함수들이 중복 작성되는 것
- 클래스의 멤버들 사이, 외부 함수들 사이, 그리고 기본 클래스와 파생 클래스 사이에 존재 가능
- 이름이 같은 여러개의 함수를 중복 작성하여 사용의 편의성 향상
- 정적 바인딩, 컴파일 시에 중복된 함수들의 호출 구분
- 컴파일 시간 다형성

2. 함수 재정의 (가상 함수가 아닌 멤버에 대해)
- 기본 클래스의 멤버 함수를 파생 클래스에서 이름, 매개 변수 타입과 개수, 리턴 타입까지 
  완벽히 같은 원형으로 재작성하는 것
- 상속 관계
- 기본 클래스의 멤버 함수와 별도로 파생 클래스에서 필요하여 재작성
- 정적 바인딩, 컴파일 시에 함수의 호출 구분
- 컴파일 시간 다형성

3. 오버라이딩
- 기본 클래스의 가상 함수를 파생 클래스에서 이름, 매개 변수 타입과 개수, 리턴 타입까지
  완벽히 같은 원형으로 재작성하는 것
- 상속 관계
- 기본 클래스에 구현된 가상 함수를 무시하고 파생 클래스에서 새로운 기능으로 재작성하고자 함
- 동적 바인딩, 실행 시간에 오버라이딩된 함수를 찾아 실행
- 실행 시간 다형성


* 파생 클래스마다 다르게 구현하는 다형성

* 파생 클래스에서 가상 함수 draw()의 재정의 
- 어떤 경우에도 자신이 만든 draw()가 호출됨을 보장 받음
	-> 동적 바인딩에 의해






04. 기본 클래스의 포인터 활용

* 기본 클래스의 포인터로 파생 클래스 접근
- pStart, pLast, p의 타입이 Shape* 
- 링크드 리스트를 따라 Shape을 상속받은 파생 객체들 접근
- p->paint()의 간단한 호출로 파생 객체에 오버라이딩된 draw() 함수 호출







05. 순수 가상 함수

* 기본 클래스의 가상 함수 목적
- 파생 클래스에서 재정의할 함수를 알려주는 역할
	: 실행할 코드를 작성할 목적이 아님
- 기본 클래스의 가상 함수를 굳이 구현할 필요가 있을까 ? -> 없음

* 순수 가상 함수
- pure virtual function
- 함수의 코드가 없고 선언만 있는 가상 멤버 함수
- 선언 방법
	: 멤버 함수의 원형 = 0;으로 선언

* 추상 클래스
- 최소한 하나의 순수 가상 함수를 가진 클래스

* 추상클래스의 특징 
- 온전한 클래스가 아니므로 객체 생성 불가능
- 추상 클래스의 포인터는 선언 가능

* 추상 클래스의 목적 
- 추상 클래스의 인스턴스를 생성할 목적 아님
- 상속에서 기본 클래스의 역할을 하기 위함
	: 순수 가상 함수를 통해 파생 클래스에서 구현할 함수의 형태(원형)을 보여주는 인터페이스 역할
	: 추상 클래스의 모든 멤버 함수를 순수 가상 함수로 선언할 필요 없음

* 추상 클래스의 상속
- 추상 클래스를 단순 상속하면 자동 추상 클래스

* 추상 클래스의 구현
- 추상 클래스를 상속받아 순수 가상 함수를 오버라이딩
	: 파생 클래스는 추상 클래스가 아님



객체지향에서 중요한 핵심은 동적바인딩





