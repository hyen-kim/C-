
================================================================================

8주차 (5장)
- 함수와 참조, 복사 생성자 

================================================================================

< 함수의 인자 전달 방식 리뷰 >	

1. 인자 전달 방식
- 값에 의한 호출, call by value
	-> 함수가 호출되면 매개 변수가 스택에 생성됨
	-> 호출하는 코드에서 값을 넘겨줌
	-> 호출하는 코드에서 넘어온 값이 매개 변수에 복사됨

- 주소에 의한 호출, call by address
	-> 함수의 매개 변수는 포인터 타입 
	: 함수가 호출되면 포인터 타입의 매개 변수가 스택에 생성됨
	-> 호출하는 코드에서는 명시적으로 주소를 넘겨줌 
	: 기본 타입 변수나 객체의 경우, 주소 전달
	: 배열의 경우, 배열의 이름
	-> 호출하는 코드에서 넘어온 주소 값이 매개 변수에 저장됨

* 값에 의한 호출 VS 주소에 의한 호출 

값에 의한 호출은 소스에 A가 있다고 하면 함수 f에게
소스 A값을 복사하여 전달하여 함수 f가 A를 가지고 처리 한 값을 
return하여 주는 것이다.
-> 원본이 변형이 되지 않는다.

주소에 의한 호출은 소스에 A가 있다고 하면 A의 주소를 함수 f에게 
넘기므로 A를 B로 변경하게 되면 변경이 된다. 
왜냐하면 함수 f는 원본을 가지고 있는 것이 아니고 주소를 가지고 있기 때문에
주소로 가서 변경하기 때문이다.
-> 원본이 변형된다.

ex) 
*swap이란 ?
- m의 값과 n의 값을 서로 교환

(a) 값에 의한 호출 
#include <iostream>
using namespace std;

void swap(int a, int b) {
	int tmp;
	
	tmp = a;
	a = b;
	b = tmp;
}
int main() {
	int m = 2, n = 9;
	swap(m, n);
	cout << m << '' << n;
}
-> call by value는 전달된걸 복사해서 사용한다.

(b) 주소에 의한 호출
#include <iostream>
using namespace std;

void swap(int *a, int *b) {
	int tmp;
	
	tmp = *a;	// a가 가리키는 곳의 값
	*a = *b;
	*b = tmp;
}
int main() {
	int m = 2, n = 9;
	swap(&m, &n);
	cout << m << '' << n;
}
-> 주는 쪽은 주소, 받는 쪽은 *(아스타)
-> 값을 가져올 때, 넣을때 는 *를 이용한다.
-> 주소값으로 전달하고, 포인터로 받는다.




< '값에 의한 호출'로 객체 전달 >
- 함수를 호출하는 쪽에서 객체 전달
	-> 객체 이름만 사용
- 함수의 매개 변수 객체 생성
	-> 매개 변수 객체의 공간이 스택에 할당
	-> 호출하는 쪽의 객체가 매개 변수 객체에 그대로 복사됨
	-> * 매개 변수 객체의 생성자는 호출되지 않음
- 함수 종류
	-> * 매개 변수 객체의 소멸자 호출
	=======> 매개 변수 객체의 생성자 소멸자의 비대칭 실행 구조
	
- 값에 의한 호출 시 매개 변수 객체의 생성자가 실행되지 않는 이유 ?
	-> 호출되는 순간의 실인자 객체 상태를 매개 변수 객체에 그대로 전달하기 위함




< 함수에 객체 전달 - '주소에 의한 호출'로 >
- 함수 호출시 객체의 주소만 전달
	-> 함수의 매개 변수는 객체에 대한 포인터 변수로 선언
	-> 함수 호출 시 생성자 소멸자가 실행되지 않는 구조






< 객체 치환 및 객체 리턴 >
- 객체 치환
	-> 동일한 클래스 타입의 객체끼리 치환 가능
	-> 객체의 모든 데이터가 비트 단위로 복사
	Circle c1(5);
	Circle c2(30);
	c1 = c2;	// c2 객체를 c1 객체에 비트 단위 복사. c1의 반지름 30됨
	-> 치환된 두 객체는 현재 내용물만 같을 뿐 독립적인 공간 유지

- 객체 리턴
	Circle getCircle(){
		Circle tmp(30);	// 생성자 동작						② 생성자	
		return tmp;	// 객체 tmp 리턴	-> 객체가 리턴되자마자 소멸	③ 소멸자
	}
	Circle c;		// c의 반지름 1						① 생성자
	c = getCircle();	// tmp 객체의 복사본이 c에 치환. c의 반지름은 30이됨	④ 소멸자
				// 여기서 치환 대입되면서 넘겨주자마자 소멸가 호출
				// 생성자가 동작하지 않음




< 참조(reference) >
- 참조란 가르킨다는 뜻으로, 이미 존재하는 객체나 변수에 대한 별명
- 참조 활용
	-> 참조 변수
	-> 참조에 의한 호출
	-> 참조 리턴
- 참조는 공간을 가지지 않음, 이름만 가지고 있음

1. 참조 변수 선언
- 참조자 &의 도입
- 이미 존재하는 변수에 대한 다른 이름(별명)을 선언
	-> 참조 변수는 이름만 생기며
	-> 참조 변수에 새로운 공간을 할당하지 않음
	-> 초기화로 지정된 기존 변수를 공유
	
	int n = 2;
	int &refn = n;	// 참조 변수 refn 선언. refn은 n에 대한 별명
	
	Circle circle;
	Circle &refc = circle;	// 참조 변수 refc 선언. refc는 circle에 대한 별명


2. 참조에 의한 호출
- 참조를 가장 많이 활용하는 사례
- call by reference라고 부름
* 함수 형식 
: 함수의 매개 변수를 참조 타입으로 선언
	-> 참조 매개 변수라고 부름
	-> 참조 매개 변수는 이름만 생기고 공간이 생기지 않음
	-> 참조 매개 변수는 실인자 변수 공간 공유
	-> 참조 매개 변수에 대한 조작은 실인자 변수 조작 효과


3. 참조 매개변수가 필요한 사례
* 다음 코드에 어떤 문제가 있을까 ?
- average() 함수의 작동
	-> 계산에 오류가 있으면 0 리턴, 아니면 평균 리턴

- 만일 average()가 리턴한 값이 0이라면 ?
	-> 평균이 0 인거야 ? 아니면 오류가 발생한거야 ?
 





< 얕은 복사와 깊은 복사 >

1. 얕은 복사 (shallow copy)
- 객체 복사 시, 객체의 멤버를 1:1로 복사
- 객체의 멤버 변수에 동적 메모리가 할당된 경우
	-> 사본은 원본 객체가 할당 받은 메모리를 공유하는 문제 발생

2. 깊은 복사 (deep copy)
- 객체 복사 시, 객체의 멤버를 1:1대로 복사
- 객체의 멤버 변수에 동적 메모리가 할당된 경우
	-> 사본은 원본이 가진 메모리 크기 만큼 별도로 동적 할당
	-> 원본의 동적 메모리에 있는 내용을 사본에 복사
- 완전한 형태의 복사 
	-> 사본과 원본은 메모리를 공유하는 문제 없음




< 복사 생성자 >
* 복사 생성자란 ?
- 객체의 복사 생성시 호출되는 특별한 생성자

* 특징
- 한 클래스에 오직 한 개만 선언 가능
- 복사 생성자는 보통 생성자와 클래스 내에 중복 선언 가능
- 모양
	-> 클래스에 대한 참조 매개 변수를 가지는 독특한 생성자

* 복사 생성자 선언
class Circle {
	....
	Circle(const Circle& c);	// 복사 생성자 선언
	....
};
Circle::Circle(const Circle& c) {	// 복사 생성자 구현
	....
}






< 디폴트 복사 생성자 >
- 복사 생성자가 선언되어 있지 않는 클래스
	-> 컴파일러는 자동으로 디폴트 복사 생성자 삽입



